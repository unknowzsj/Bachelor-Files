#include<iostream>
#include<cstring>
#include<map>
#include<queue>
using namespace std;
//地图的样式
//为了方便界定首位，将maps加s，就能保证被50整除
//bfs得出的就是最短路径
//走过的地方将其置1，防止回走 
string maps=
"s01010101001011001001010110010110100100001000101010" 
 "00001000100000101010010000100000001001100110100101"
 "01111011010010001000001101001011100011000000010000"
 "01000000001010100011010000101000001010101011001011"
 "00011111000000101000010010100010100000101100000000"
 "11001000110101000010101100011010011010101011110111"
 "00011011010101001001001010000001000101001110000000" 
 "10100000101000100110101010111110011000010000111010"
 "00111000001010100001100010000001000101001100001001"
 "11000110100001110010001001010101010101010001101000"
 "00010000100100000101001010101110100010101010000101"
 "11100100101001001000010000010101010100100100010100"
 "00000010000000101011001111010001100000101010100011"
 "10101010011100001000011000010110011110110100001000"
 "10101010100001101010100101000010100000111011101001"
 "10000000101100010000101100101101001011100000000100"
 "10101001000000010100100001000100000100011110101001"
 "00101001010101101001010100011010101101110000110101"
 "11001010000100001100000010100101000001000111000010"
 "00001000110000110101101000000100101001001000011101"
 "10100101000101000000001110110010110101101010100001"
 "00101000010000110101010000100010001001000100010101"
 "10100001000110010001000010101001010101011111010010"
 "00000100101000000110010100101001000001000000000010"
 "11010000001001110111001001000011101001011011101000"
 "00000110100010001000100000001000011101000000110011"
 "10101000101000100010001111100010101001010000001000"
 "10000010100101001010110000000100101010001011101000"
 "00111100001000010000000110111000000001000000001011"
 "10000001100111010111010001000110111010101101111000";
//防止重复走 
map<string,bool> sta;
//记录成功路径 
int y=0;
string res[10000];
//记录当前位置
struct node{
	pair<int,string> h;
};
queue<node> cur; 
//L,R,D,U 
pair<int,char> mv[4];
//bfs
void bfs(int curl,string lu){
	//遍历每个位置
	for(int i=0;i<4;++i){
		int newcur=curl+mv[i].first; 
		//越界，或首尾相连 
		if((newcur%50==0&&curl%50==1)||(newcur%50==1&&curl%50==0)||newcur<0||newcur>1500) continue;
		//遇到墙不走 
		if(maps[newcur]=='1'){
			continue;
		}
		//更新结点 
		else{
			node nsta;
			nsta.h.first=newcur;
			nsta.h.second=lu+mv[i].second;
			if(!sta[nsta.h.second]){
				sta[nsta.h.second]=true;
				//防止走回头路 
				maps[newcur]='1';
				cur.push(nsta);
			}
		}
	} 
} 
int main(){
	//移动初始化，
	//为了是字典序最小，让优先级高的在前面 
	mv[0].first=50;
	mv[0].second='D';
	mv[1].first=-1;
	mv[1].second='L';
	mv[2].first=1;
	mv[2].second='R';
	mv[3].first=-50;
	mv[3].second='U';
	//初始化，0步，路径为空 
	node start;
	start.h.first=1;
	start.h.second="";
	cur.push(start);
	
	int t=cur.size();
	while(!cur.empty()){
		//读取先进的状态 
		node frn=cur.front();
		int loc=frn.h.first;
		string lujin=frn.h.second;
		cur.pop();
		//找到出路 
		if(loc==1500){
			cout<<lujin<<endl;
		}
		//下一个遍历
		bfs(loc,lujin);
		t--;
		if(t==0){
			t=cur.size();
		} 
	}
} 
